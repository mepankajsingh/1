---
import Layout from '../../layouts/Layout.astro';
import LibraryCard from '../../components/LibraryCard.astro';
import FilterBar from '../../components/FilterBar.jsx';
import SortBar from '../../components/SortBar.jsx';
import { supabase } from '../../lib/supabase';

export const prerender = false;

// Get all libraries with their frameworks
const { data: libraries } = await supabase
  .from('libraries')
  .select(`
    *,
    frameworks:library_frameworks(
      is_primary,
      framework_id(id, name, slug)
    ),
    tags:library_tags(tag_id(id, name, slug))
  `)
  .order('name');

// Get all frameworks for the filter
const { data: frameworks } = await supabase
  .from('frameworks')
  .select('id, name, slug')
  .order('name');

// Get all tags for the filter
const { data: tags } = await supabase
  .from('tags')
  .select('id, name, slug')
  .order('name');

// Initial filter state
const initialFilters = {
  minComponents: '',
  minDownloads: '',
  lastUpdated: '',
  tags: []
};

// Initial sort state
const initialSort = {
  field: 'popularity',
  direction: 'desc'
};

// Prepare libraries data for client-side filtering
const librariesData = libraries ? libraries.map(library => {
  return {
    id: library.id,
    name: library.name,
    slug: library.slug,
    total_components: library.total_components,
    npm_downloads: library.npm_downloads,
    github_stars: library.github_stars,
    last_update: library.last_update,
    tags: library.tags ? library.tags.map(t => t.tag_id?.name?.toLowerCase()) : []
  };
}) : [];
---

<Layout title="UI Component Libraries">
  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <div class="mb-8">
      <h1 class="text-2xl font-bold text-gray-900 mb-2">UI Component Libraries</h1>
      <p class="text-gray-600">
        Discover the best UI component libraries for your next project.
      </p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
      <!-- Sidebar with filters -->
      <div class="lg:col-span-1">
        <FilterBar client:load initialFilters={initialFilters} />
      </div>
      
      <!-- Main content area -->
      <div class="lg:col-span-3">
        <SortBar client:load initialSort={initialSort} />
        
        <div id="libraries-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
          {libraries && libraries.map(library => (
            <div class="library-card" data-library-id={library.id}>
              <LibraryCard library={library} />
            </div>
          ))}
        </div>
        
        {(!libraries || libraries.length === 0) && (
          <div class="text-center py-12">
            <p class="text-gray-500">No libraries found.</p>
          </div>
        )}
      </div>
    </div>
  </main>

  <script define:vars={{ librariesData }}>
    // Client-side filtering and sorting logic
    document.addEventListener('DOMContentLoaded', () => {
      const librariesContainer = document.getElementById('libraries-container');
      
      // Initialize with stored values or defaults
      let currentFilters = {
        minComponents: '',
        minDownloads: '',
        lastUpdated: '',
        tags: []
      };
      
      let currentSort = {
        field: 'popularity',
        direction: 'desc'
      };
      
      // Try to load saved filters and sort from sessionStorage
      try {
        const savedFilters = sessionStorage.getItem('ui-library-filters');
        if (savedFilters) {
          currentFilters = JSON.parse(savedFilters);
          console.log('Loaded filters from sessionStorage:', currentFilters);
        }
        
        const savedSort = sessionStorage.getItem('ui-library-sort');
        if (savedSort) {
          currentSort = JSON.parse(savedSort);
          console.log('Loaded sort from sessionStorage:', currentSort);
        }
      } catch (e) {
        console.error('Failed to load from sessionStorage:', e);
      }

      // Function to apply filters and sorting
      function applyFiltersAndSort() {
        console.log('Applying filters:', currentFilters);
        console.log('Applying sort:', currentSort);
        
        // Get all libraries that match the current filters
        const filteredLibraries = librariesData.filter(library => {
          // Apply component count filter
          if (currentFilters.minComponents && 
              parseInt(currentFilters.minComponents) > 0 &&
              (!library.total_components || library.total_components < parseInt(currentFilters.minComponents))) {
            return false;
          }
          
          // Apply downloads filter
          if (currentFilters.minDownloads && 
              parseInt(currentFilters.minDownloads) > 0 &&
              (!library.npm_downloads || library.npm_downloads < parseInt(currentFilters.minDownloads))) {
            return false;
          }
          
          // Apply last updated filter
          if (currentFilters.lastUpdated && parseInt(currentFilters.lastUpdated) > 0) {
            const daysAgo = parseInt(currentFilters.lastUpdated);
            if (!library.last_update) return false;
            
            const lastUpdated = new Date(library.last_update);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysAgo);
            
            if (lastUpdated < cutoffDate) {
              return false;
            }
          }
          
          // Apply tags filter
          if (currentFilters.tags && currentFilters.tags.length > 0) {
            const libraryTags = library.tags || [];
            if (!currentFilters.tags.some(tag => libraryTags.includes(tag))) {
              return false;
            }
          }
          
          return true;
        });
        
        console.log('Filtered libraries:', filteredLibraries);
        
        // Sort the filtered libraries
        filteredLibraries.sort((a, b) => {
          let valueA, valueB;
          
          switch (currentSort.field) {
            case 'name':
              valueA = a.name || '';
              valueB = b.name || '';
              break;
            case 'downloads':
              valueA = a.npm_downloads || 0;
              valueB = b.npm_downloads || 0;
              break;
            case 'components':
              valueA = a.total_components || 0;
              valueB = b.total_components || 0;
              break;
            case 'updated':
              valueA = new Date(a.last_update || 0).getTime();
              valueB = new Date(b.last_update || 0).getTime();
              break;
            case 'popularity':
            default:
              valueA = a.github_stars || 0;
              valueB = b.github_stars || 0;
              break;
          }
          
          const multiplier = currentSort.direction === 'desc' ? -1 : 1;
          
          if (typeof valueA === 'string' && typeof valueB === 'string') {
            return multiplier * valueA.localeCompare(valueB);
          } else {
            return multiplier * (valueA - valueB);
          }
        });
        
        // Update the DOM to reflect filtered and sorted libraries
        if (librariesContainer) {
          // Hide all library cards first
          const allCards = document.querySelectorAll('.library-card');
          allCards.forEach(card => {
            card.style.display = 'none';
          });
          
          // Show and reorder the filtered cards
          filteredLibraries.forEach((library, index) => {
            const card = document.querySelector(`.library-card[data-library-id="${library.id}"]`);
            if (card) {
              card.style.display = 'block';
              // Move to the correct position
              librariesContainer.appendChild(card);
            }
          });
        }
      }

      // Listen for filter changes - use document instead of window
      document.addEventListener('filter-change', (event) => {
        console.log('Filter change event received:', event.detail);
        currentFilters = event.detail;
        applyFiltersAndSort();
      });
      
      // Listen for sort changes - use document instead of window
      document.addEventListener('sort-change', (event) => {
        console.log('Sort change event received:', event.detail);
        currentSort = event.detail;
        applyFiltersAndSort();
      });
      
      // Apply initial filters and sorting immediately
      applyFiltersAndSort();
      
      // Set up a MutationObserver to detect when the React components are fully rendered
      const observer = new MutationObserver((mutations) => {
        // Check if our filter/sort components are in the DOM
        const filterBarExists = document.querySelector('.filter-bar');
        const sortBarExists = document.querySelector('.sort-bar');
        
        if (filterBarExists || sortBarExists) {
          // Components are in the DOM, disconnect observer
          observer.disconnect();
          
          // Re-apply filters and sorting to ensure everything is properly rendered
          setTimeout(() => {
            applyFiltersAndSort();
          }, 100);
        }
      });
      
      // Start observing the document with the configured parameters
      observer.observe(document.body, { childList: true, subtree: true });
      
      // Set up a fallback timer in case the components never fully render
      setTimeout(() => {
        applyFiltersAndSort();
        observer.disconnect();
      }, 1000);
    });
  </script>
  
  <!-- Hydration fix script - runs before React hydration -->
  <script>
    // This script runs before React hydration to ensure we have access to stored filters/sort
    (function() {
      // Try to load saved filters and sort from sessionStorage
      try {
        const savedFilters = sessionStorage.getItem('ui-library-filters');
        const savedSort = sessionStorage.getItem('ui-library-sort');
        
        // Create a global object to store these values for React components to access
        window.__UI_LIBRARY_STATE__ = {
          filters: savedFilters ? JSON.parse(savedFilters) : null,
          sort: savedSort ? JSON.parse(savedSort) : null
        };
        
        console.log('Pre-hydration state loaded:', window.__UI_LIBRARY_STATE__);
      } catch (e) {
        console.error('Failed to load pre-hydration state:', e);
      }
    })();
  </script>
</Layout>
